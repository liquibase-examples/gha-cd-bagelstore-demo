template:
  name: Coordinated DB and App Deployment
  identifier: Coordinated_DB_App_Deployment
  versionLabel: v1.0
  type: StepGroup
  projectIdentifier: bagel_store_demo
  orgIdentifier: default
  tags:
    purpose: coordinated_deployment
    components: database_application
  description: |
    Reusable step group for deploying database changes and application updates.
    Supports both AWS (RDS + App Runner) and Local (Docker Compose) deployment modes.

    Steps:
    1. Fetch Changelog Artifact - Downloads changelog zip from GitHub Packages
    2. Update Database - Runs Liquibase update via Docker container
    3a. Update SSM Image Tag - Writes image version to SSM Parameter Store
    3b. Deploy Application via Terraform - Runs terraform apply (reads SSM, updates App Runner)
    4. Health Check - Verifies deployment success with version check
    5. Fetch Instances - Reports instance information to Harness for tracking

    NOTE: Terraform files must be available on delegate at /opt/harness-delegate/terraform
    (mounted from repository or cloned separately)

    Environment variables used (automatically resolved from stage context):
    - env.variables.environment: Target environment (dev/test/staging/prod)
    - env.variables.demo_id: Demo instance identifier
    - env.variables.jdbc_url: Database connection URL
    - env.variables.rds_address: RDS endpoint address
    - env.variables.rds_port: RDS port
    - env.variables.database_name: Database name
    - env.variables.app_runner_service_arn: App Runner service ARN
    - env.variables.app_runner_service_url: App Runner service URL
    - env.variables.liquibase_flows_bucket: S3 bucket for flow files
    - env.variables.aws_region: AWS region

    Pipeline variables used:
    - pipeline.variables.VERSION: Git tag version to deploy
    - pipeline.variables.GITHUB_ORG: GitHub organization name

    Deployment mode controlled by:
    - DEPLOYMENT_TARGET environment variable: "aws" (default) or "local"

  spec:
    steps:
      # Step 1: Fetch changelog artifact from GitHub Actions
      - step:
          type: ShellScript
          name: Fetch Changelog Artifact
          identifier: Fetch_Changelog_Artifact
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  /opt/harness-delegate/scripts/fetch-changelog-artifact.sh \
                    "<+pipeline.variables.VERSION>" \
                    "<+pipeline.variables.GITHUB_ORG>" \
                    "<+secrets.getValue('github_pat')>"
            environmentVariables: []
            outputVariables: []
          timeout: 5m

      # Step 2: Update database with Liquibase
      - step:
          type: ShellScript
          name: Update Database
          identifier: Update_Database
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  # Build AWS parameters JSON
                  AWS_PARAMS=$(cat <<'EOF'
                  {
                    "jdbc_url": "<+env.variables.jdbc_url>",
                    "aws_region": "<+env.variables.aws_region>",
                    "liquibase_flows_bucket": "<+env.variables.liquibase_flows_bucket>",
                    "rds_endpoint": "<+env.variables.rds_endpoint>"
                  }
                  EOF
                  )

                  # Build secrets JSON
                  # Note: Database credentials fetched via Liquibase native AWS Secrets Manager integration
                  SECRETS=$(cat <<'EOF'
                  {
                    "aws_access_key_id": "<+secrets.getValue('aws_access_key_id')>",
                    "aws_secret_access_key": "<+secrets.getValue('aws_secret_access_key')>",
                    "liquibase_license_key": "<+secrets.getValue('liquibase_license_key')>"
                  }
                  EOF
                  )

                  /opt/harness-delegate/scripts/update-database.sh \
                    "<+env.variables.environment>" \
                    "<+env.variables.demo_id>" \
                    "${DEPLOYMENT_TARGET:-aws}" \
                    "$AWS_PARAMS" \
                    "$SECRETS"
            environmentVariables: []
            outputVariables: []
          timeout: 10m

      # Step 3a: Clone Terraform code
      - step:
          type: ShellScript
          name: Clone Terraform Code
          identifier: Clone_Terraform_Code
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  # Clone repository to get Terraform files
                  # Delegate needs Terraform code to run terraform apply

                  WORK_DIR="/tmp/harness-terraform-$$"
                  mkdir -p "$WORK_DIR"
                  cd "$WORK_DIR"

                  echo "Cloning repository..."
                  git clone --depth 1 --branch main \
                    https://<+secrets.getValue('github_pat')>@github.com/<+pipeline.variables.GITHUB_ORG>/harness-gha-bagelstore.git

                  echo "Copying Terraform files to delegate..."
                  mkdir -p /opt/harness-delegate/terraform
                  cp -r harness-gha-bagelstore/terraform/* /opt/harness-delegate/terraform/

                  echo "✅ Terraform code ready at /opt/harness-delegate/terraform"

                  # Cleanup
                  cd /
                  rm -rf "$WORK_DIR"
            environmentVariables: []
            outputVariables: []
          timeout: 3m

      # Step 3b: Update SSM Parameter with image tag
      - step:
          type: ShellScript
          name: Update SSM Image Tag
          identifier: Update_SSM_Image_Tag
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  # Write image tag to SSM Parameter Store
                  # Terraform will read this value when applying infrastructure changes

                  echo "Writing image tag to SSM: /<+env.variables.demo_id>/image-tags/<+env.variables.environment>"

                  aws ssm put-parameter \
                    --name "/<+env.variables.demo_id>/image-tags/<+env.variables.environment>" \
                    --value "<+pipeline.variables.VERSION>" \
                    --type String \
                    --overwrite \
                    --region <+env.variables.aws_region>

                  echo "✅ SSM parameter updated: <+pipeline.variables.VERSION>"
            environmentVariables:
              - name: AWS_ACCESS_KEY_ID
                value: <+secrets.getValue('aws_access_key_id')>
              - name: AWS_SECRET_ACCESS_KEY
                value: <+secrets.getValue('aws_secret_access_key')>
            outputVariables: []
          timeout: 2m

      # Step 3c: Deploy application via Terraform
      - step:
          type: ShellScript
          name: Deploy Application via Terraform
          identifier: Deploy_Application_Terraform
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  # Deploy application by running Terraform apply
                  # Terraform reads image tag from SSM and updates App Runner service

                  echo "Deploying via Terraform for environment: <+env.variables.environment>"

                  cd /opt/harness-delegate/terraform

                  # Configure AWS credentials for Terraform
                  export AWS_ACCESS_KEY_ID="<+secrets.getValue('aws_access_key_id')>"
                  export AWS_SECRET_ACCESS_KEY="<+secrets.getValue('aws_secret_access_key')>"
                  export AWS_DEFAULT_REGION="<+env.variables.aws_region>"

                  # Initialize Terraform (loads S3 backend)
                  terraform init -input=false

                  # Apply targeted update to specific environment's App Runner service
                  terraform apply \
                    -target="aws_apprunner_service.bagel_store[\"<+env.variables.environment>\"]" \
                    -auto-approve \
                    -input=false

                  echo "✅ Terraform apply completed"
            environmentVariables: []
            outputVariables:
              - name: SERVICE_URL
                type: String
                value: service_url
          timeout: 15m

      # Step 4: Health check
      - step:
          type: ShellScript
          name: Health Check
          identifier: Health_Check
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  /opt/harness-delegate/scripts/health-check.sh \
                    "<+env.variables.environment>" \
                    "<+pipeline.variables.VERSION>" \
                    "${DEPLOYMENT_TARGET:-aws}" \
                    "<+env.variables.app_runner_service_url>"
            environmentVariables: []
            outputVariables: []
          timeout: 10m

      # Step 5: Fetch Instance Script (required for CustomDeployment tracking)
      - step:
          type: FetchInstanceScript
          name: Fetch Instances
          identifier: Fetch_Instances
          spec:
            shell: Bash
            source:
              type: Inline
              spec:
                script: |-
                  /opt/harness-delegate/scripts/fetch-instances.sh \
                    "<+env.variables.environment>" \
                    "${DEPLOYMENT_TARGET:-aws}" \
                    "<+env.variables.app_runner_service_name>" \
                    "<+env.variables.app_runner_service_url>"
            outputVariables: []
            environmentVariables: []
          timeout: 5m

    stageType: Deployment
