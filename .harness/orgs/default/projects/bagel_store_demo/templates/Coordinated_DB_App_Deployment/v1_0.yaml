template:
  name: Coordinated DB and App Deployment
  identifier: Coordinated_DB_App_Deployment
  versionLabel: v1.0
  type: StepGroup
  projectIdentifier: bagel_store_demo
  orgIdentifier: default
  tags:
    purpose: coordinated_deployment
    components: database_application
  description: |
    Reusable step group for deploying database changes and application updates.
    Supports both AWS (RDS + App Runner) and Local (Docker Compose) deployment modes.

    Steps:
    1. Fetch Changelog Artifact - Downloads changelog zip from GitHub Actions artifacts
    2. Update Database - Runs Liquibase update via Docker container
    3. Deploy Application - Updates App Runner (AWS) or Docker Compose (local) via deployment script
    4. Health Check - Verifies deployment success with version check
    5. Fetch Instances - Reports instance information to Harness for tracking

    Architecture:
    - Uses external deployment scripts (bind mounted to delegate from harness/scripts/)
    - Scripts update automatically on git push (no UI refresh needed)
    - For AWS: Calls aws apprunner update-service directly (no Terraform)
    - For local: Updates Docker Compose with new version

    Environment variables used (automatically resolved from stage context):
    - env.variables.environment: Target environment (dev/test/staging/prod)
    - env.variables.demo_id: Demo instance identifier
    - env.variables.jdbc_url: Database connection URL
    - env.variables.rds_address: RDS endpoint address
    - env.variables.rds_port: RDS port
    - env.variables.database_name: Database name
    - env.variables.app_runner_service_arn: App Runner service ARN
    - env.variables.app_runner_service_url: App Runner service URL
    - env.variables.liquibase_flows_bucket: S3 bucket for flow files
    - env.variables.aws_region: AWS region
    - env.variables.secrets_username_arn: AWS Secrets Manager ARN for DB username
    - env.variables.secrets_password_arn: AWS Secrets Manager ARN for DB password
    - env.variables.ecr_public_alias: ECR public alias for Docker images

    Pipeline variables used:
    - pipeline.variables.VERSION: Git tag version to deploy
    - pipeline.variables.GITHUB_ORG: GitHub organization name

    Deployment mode controlled by:
    - DEPLOYMENT_TARGET environment variable: "aws" (default) or "local"

  spec:
    steps:
      # Step 1: Fetch changelog artifact from GitHub Actions
      - step:
          type: ShellScript
          name: Fetch Changelog Artifact
          identifier: Fetch_Changelog_Artifact
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  /opt/harness-delegate/scripts/fetch-changelog-artifact.sh \
                    "<+pipeline.variables.VERSION>" \
                    "<+pipeline.variables.GITHUB_ORG>" \
                    "<+secrets.getValue('github_pat')>"
            environmentVariables: []
            outputVariables: []
          timeout: 5m

      # Step 2: Update database with Liquibase
      - step:
          type: ShellScript
          name: Update Database
          identifier: Update_Database
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  # Build AWS parameters JSON
                  AWS_PARAMS=$(cat <<'EOF'
                  {
                    "jdbc_url": "<+env.variables.jdbc_url>",
                    "aws_region": "<+env.variables.aws_region>",
                    "liquibase_flows_bucket": "<+env.variables.liquibase_flows_bucket>",
                    "rds_endpoint": "<+env.variables.rds_endpoint>"
                  }
                  EOF
                  )

                  # Build secrets JSON
                  # Note: Database credentials fetched via Liquibase native AWS Secrets Manager integration
                  SECRETS=$(cat <<'EOF'
                  {
                    "aws_access_key_id": "<+secrets.getValue('aws_access_key_id')>",
                    "aws_secret_access_key": "<+secrets.getValue('aws_secret_access_key')>",
                    "liquibase_license_key": "<+secrets.getValue('liquibase_license_key')>"
                  }
                  EOF
                  )

                  /opt/harness-delegate/scripts/update-database.sh \
                    "<+env.variables.environment>" \
                    "<+env.variables.demo_id>" \
                    "${DEPLOYMENT_TARGET:-aws}" \
                    "$AWS_PARAMS" \
                    "$SECRETS"
            environmentVariables: []
            outputVariables: []
          timeout: 10m

      # Step 3: Deploy application
      - step:
          type: ShellScript
          name: Deploy Application
          identifier: Deploy_Application
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  # Build AWS parameters JSON
                  AWS_PARAMS=$(cat <<'EOF'
                  {
                    "app_runner_service_arn": "<+env.variables.app_runner_service_arn>",
                    "aws_region": "<+env.variables.aws_region>",
                    "demo_id": "<+env.variables.demo_id>",
                    "rds_address": "<+env.variables.rds_address>",
                    "rds_port": "<+env.variables.rds_port>",
                    "database_name": "<+env.variables.database_name>",
                    "secrets_username_arn": "<+env.variables.secrets_username_arn>",
                    "secrets_password_arn": "<+env.variables.secrets_password_arn>",
                    "ecr_public_alias": "<+env.variables.ecr_public_alias>"
                  }
                  EOF
                  )

                  # Build secrets JSON
                  SECRETS=$(cat <<'EOF'
                  {
                    "aws_access_key_id": "<+secrets.getValue('aws_access_key_id')>",
                    "aws_secret_access_key": "<+secrets.getValue('aws_secret_access_key')>"
                  }
                  EOF
                  )

                  /opt/harness-delegate/scripts/deploy-application.sh \
                    "<+env.variables.environment>" \
                    "<+pipeline.variables.VERSION>" \
                    "<+pipeline.variables.GITHUB_ORG>" \
                    "${DEPLOYMENT_TARGET:-aws}" \
                    "$AWS_PARAMS" \
                    "$SECRETS"
            environmentVariables: []
            outputVariables: []
          timeout: 10m

      # Step 4: Health check
      - step:
          type: ShellScript
          name: Health Check
          identifier: Health_Check
          spec:
            shell: Bash
            executionTarget: {}
            source:
              type: Inline
              spec:
                script: |-
                  /opt/harness-delegate/scripts/health-check.sh \
                    "<+env.variables.environment>" \
                    "<+pipeline.variables.VERSION>" \
                    "${DEPLOYMENT_TARGET:-aws}" \
                    "<+env.variables.app_runner_service_url>"
            environmentVariables: []
            outputVariables: []
          timeout: 10m

      # Step 5: Fetch Instance Script (required for CustomDeployment tracking)
      - step:
          type: FetchInstanceScript
          name: Fetch Instances
          identifier: Fetch_Instances
          spec:
            shell: Bash
            source:
              type: Inline
              spec:
                script: |-
                  /opt/harness-delegate/scripts/fetch-instances.sh \
                    "<+env.variables.environment>" \
                    "${DEPLOYMENT_TARGET:-aws}" \
                    "<+env.variables.app_runner_service_name>" \
                    "<+env.variables.app_runner_service_url>"
            outputVariables: []
            environmentVariables: []
          timeout: 5m

    stageType: Deployment
